package Interprete;

import java_cup.runtime.*;
import nodos.*;

parser code {:

/***********
SymbolFactory es una nueva caracteristica que ha sido añadida a las version 11a de cup, la cual facilita la implementacion de clases Symbol personalizadas
, esto debido a que dicha clase no provee mucha información de contexto que podria ser util para el analisis semantico o ayudar en la construccion del AST
Mas informacion en: http//4thmouse.com/index.php/2007/02/15/using-custom-symbols-in-cup/
***********/
	public static void main(String args[]) throws Exception {
		//TinySymbolFactory sf = new TinySymbolFactory();
		SymbolFactory sf = new DefaultSymbolFactory();
		if (args.length==0) 
			new parser(new Scanner(System.in,sf),sf).parse();
		else 
			new parser(new Scanner(new java.io.FileInputStream(args[0]),sf),sf).parse();
			

	}

:}

action code {:

			private boolean debug = true;
			private NodoBase raiz=null;
			
			public NodoBase getRaiz(){
				return raiz;
			}
			
			:}
			
/* Simbolos Terminales */

terminal SEL;
terminal PRO;
terminal UNI;
terminal DIF;
terminal PROC;
terminal INT;
terminal DIV;
terminal REUN;
terminal AND;
terminal NOT;
terminal OR;
terminal EQ;
terminal DIFERENTE;
terminal MAYOR;
terminal MAYOREQ;
terminal MENOR;
terminal MENOREQ;
terminal SUMA;
terminal RESTA;
terminal MULTI;
terminal DIVI;
terminal IPAREN;
terminal DPAREN;
terminal COMA;
terminal COMI;
terminal FECHA;
terminal Integer NUM;
terminal String ID;

/* Simbolos No Terminales */

non terminal NodoBase expresion;
non terminal NodoBase predicado;
non terminal NodoBase restriccion;
non terminal NodoBase nombre;
non terminal NodoBase relacion;

precedence left SEL, PRO;
precedence left PROC, REUN, INT, UNI, DIF, DIV;
precedence left AND, OR, NOT;
precedence left IPAREN, DPAREN;
precedence left SUMA, RESTA;
precedence left MULTI, DIVI;

/* REGLAS GRAMATICALES */

expresion		 	::= relacion:relacion{:
							
					:}
					| expresion:condicionI UNI expresion:condicionD{:
						if(raiz==null){
							raiz= new NodoOperacion(sym.UNI,condicionI,condicionD);
						}else{
							NodoBase aux = raiz;
							while(aux.tieneHermano())
								aux = aux.getHermanoDerecha();
							aux.setHermanoDerecha(new NodoOperacion(sym.UNI,condicionI,condicionD));
						}
					:}
					| expresion:condicionI INT expresion:condicionD {:
						if(raiz==null){
							raiz = new NodoOperacion(sym.INT,condicionI,condicionD);
						}else{
							NodoBase aux = raiz;
							while(aux.tieneHermano())
								aux = aux.getHermanoDerecha();
							aux.setHermanoDerecha(new NodoOperacion(sym.INT,condicionI,condicionD));
						}
					:}
					| expresion:condicionI DIV expresion:condicionD {:
						if(raiz==null){
							raiz = new NodoOperacion(sym.DIV,condicionI,condicionD);
						}else{
							NodoBase aux = raiz;
							while(aux.tieneHermano())
								aux = aux.getHermanoDerecha();
							aux.setHermanoDerecha(new NodoOperacion(sym.DIV,condicionI,condicionD));
						}
					:}
					| expresion:condicionI DIF expresion:condicionD {:
						if(raiz==null){
							raiz = new NodoOperacion(sym.DIF,condicionI,condicionD);
						}else{
							NodoBase aux = raiz;
							while(aux.tieneHermano())
								aux = aux.getHermanoDerecha();
							aux.setHermanoDerecha(new NodoOperacion(sym.DIF,condicionI,condicionD));
						}
					:}
					| expresion:condicionI PROC expresion:condicionD {:
						if(raiz==null){
							raiz = new NodoOperacion(sym.PROC,condicionI,condicionD);
						}else{
							NodoBase aux = raiz;
							while(aux.tieneHermano())
								aux = aux.getHermanoDerecha();
							aux.setHermanoDerecha(new NodoOperacion(sym.PROC,condicionI,condicionD));
						}
					:}
					| expresion:condicionI REUN expresion:condicionD {:
						if(raiz==null){
							raiz = new NodoOperacion(sym.REUN,condicionI,condicionD);
						}else{
							NodoBase aux = raiz;
							while(aux.tieneHermano())
								aux = aux.getHermanoDerecha();
							aux.setHermanoDerecha(new NodoOperacion(sym.REUN,condicionI,condicionD));
						}
					:}
					| SEL predicado:restricciones IPAREN expresion:exp DPAREN {:
						if(raiz==null){
								raiz = new NodoExpresion(sym.SEL,restricciones,exp);
						}else{
							NodoBase aux = raiz;
							while(aux.tieneHermano()) 
								aux = aux.getHermanoDerecha();
							aux.setHermanoDerecha(new NodoExpresion(sym.SEL,restricciones,exp));
						}
					:}
					| PRO predicado:restricciones IPAREN expresion:exp DPAREN {:
						if(raiz==null){
							raiz = new NodoExpresion(sym.PRO,restricciones,exp);
						}else{
							NodoBase aux = raiz;
							while(aux.tieneHermano()) 
								aux = aux.getHermanoDerecha();
							aux.setHermanoDerecha(new NodoExpresion(sym.PRO,restricciones,exp));
						}
					:}
			;
			
predicado			::= predicado:condiciones COMA restriccion:restriccion {:

					:}	
					| IPAREN restriccion:condiciones DPAREN AND predicado:restricciones 
					| IPAREN restriccion:condiciones DPAREN OR predicado:restricciones
					| IPAREN restriccion:condiciones DPAREN NOT predicado:restricciones
					| IPAREN restriccion:condiciones DPAREN 
					| restriccion:restriccion 
			;

restriccion			::= nombre:campo{:
						
					:}
					| nombre:campo EQ nombre:condicion{:
						/*RESULT = new NodoComparacion(campo,tipoOp.igual,condicion);*/
					:}
					| nombre:campo DIFERENTE nombre:condicion {:
						
					:}
					| nombre:campo MENOR nombre:condicion {:
						
					:}
					| nombre:campo MENOREQ nombre:condicion {:
						
					:}
					| nombre:campo MAYOR nombre:condicion {:
						
					:}
					| nombre:campo MAYOREQ nombre:condicion {:
						
					:}
					| restriccion:resI AND restriccion:resD 
					| restriccion:resI OR restriccion:resD
					| restriccion:resI NOT restriccion:resD 
					| IPAREN nombre:operacion DPAREN
			;
relacion			::= ID:palabra {:
						
					:}
					| ID:palabra ID:sinonimo
			;
			
nombre				::= ID:palabra {:
						
					:}
					| COMI ID:palabra COMI {:
						
					:}
					| NUM:numero {:
						
					:}
					| FECHA:fecha {:
						
					:}
					| nombre:opeI SUMA nombre:opeD {:
						/*RESULT = new NodoComparacion(opeI,tipoOp.suma,opeD);*/
					:}
					| nombre:opeI RESTA nombre:opeD {:
						
					:}
					| nombre:opeI MULTI nombre:opeD {:
						
					:}
					| nombre:opeI DIVI nombre:opeD {:
						
					:}
			;			